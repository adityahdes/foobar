# Given a minion ID as a string n representing a nonnegative integer of length k in base b, where 2 <= k <= 9 and 2
# <= b <= 10, write a function solution(n, b) which returns the length of the ending cycle of the algorithm above
# starting with n. For instance, in the example above, solution(210022, 3) would return 3, since iterating on 102212
# would return to 210111 when done in base 3. If the algorithm reaches a constant, such as 0, then the length is 1.


def solution(n, b):
    id_list = []  # an array containing all the minion IDs generated by Lambda's ingenious method
    # new IDs are added to the list at index zero, which makes it very easy to determine the length of a loop by simply
    # returning the index + 1 of the second occurrence of the ID in the array (once it is found, of course).
    while True:
        x = "".join(sorted(str(n), reverse=True))
        y = "".join(sorted(str(n)))
        z = subtract(x, y, b)
        z_len = len(str(z))
        k = len(str(x))  # the length of both x and y

        if z_len != k:
            z = z * int(10 ** (k - z_len))  # adds leading zeros to maintain length if necessary

        for index, item in enumerate(id_list):
            if item == z:
                return index + 1
        id_list = [z] + id_list
        n = z


def decimal_to_base_n(decimal_value, base):
    digits = []
    while decimal_value > 0:
        digits.insert(0, str(decimal_value % base))
        decimal_value = decimal_value / base
    return ''.join(digits)


def base_n_to_decimal(str_val, base):
    decimal_value = 0
    for n in str(str_val):
        decimal_value = base * decimal_value + int(n)
    return int(decimal_value)


def subtract(n1, n2, base):
    if base == 10:
        return int(n1) - int(n2)
    diff = base_n_to_decimal(n1, base) - base_n_to_decimal(n2, base)
    return decimal_to_base_n(diff, base)

